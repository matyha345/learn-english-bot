require('dotenv').config()

const {
	Bot,
	Keyboard,
	InlineKeyboard,
	GrammyError,
	HttpError
} = require('grammy')

const {
	getRandomTest,
	getCorrectAnswer,
	getNextQuestion
} = require('./src/components/utils/utils')

const bot = new Bot(process.env.BOT_API_KEY)

bot.command('start', async ctx => {
	const startKeyboard = new Keyboard()
		.text('All words')
		.text('New words')
		.row()
		.text('Grammar')
		.resized()

	await ctx.reply(
		'–ü—Ä–∏–≤–µ—Ç! –Ø –ë–æ—Ç, –ë–æ—Ç –¥–ª—è –∏–∑—É—á–µ–Ω–∏—è –∞–Ω–≥–ª–∏–π—Å–∫–æ–≥–æü§ñ \n–Ø –ø–æ–º–æ–≥—É —Ç–µ–±–µ —Ä–∞—Å—à–∏—Ä–∏—Ç—å —Å–≤–æ–π —Å–ª–æ–≤–∞—Ä–Ω—ã–π –∑–∞–ø–∞—Å —á–µ—Ä–µ–∑ —Ç–µ—Å—Ç—ãü•∑'
	)
	await ctx.reply(
		'–ù–∞—á–Ω–µ–º —É—á–∏—Ç—å—Å—è... –Ω–∞ –¥–∞–Ω–Ω—ã–π –º–æ–º–µ–Ω—Ç —É –º–µ–Ω—è –µ—Å—Ç—å 400 —Å–ª–æ–≤ –¥–ª—è –ø–æ–≤—Ç–æ—Ä–µ–Ω–∏—è.\n–ù–∞–∂–º–∏—Ç–µ –Ω–∞ –∫–Ω–æ–ø–∫—Éüëá',
		{
			reply_markup: startKeyboard
		}
	)
})

bot.hears('Grammar', async ctx => {
    const topic = ctx.message.text.toLowerCase();

    const question = getNextQuestion(topic);

    await ctx.replyWithPhoto(
        question.img,
        {
            caption: `<b>${question.text}</b>`,
            parse_mode: 'HTML'
        }
    );
});

bot.hears(['All words', 'New words'], async ctx => {
	const topic = ctx.message.text.toLowerCase().replace(/\s/g, '')

	let question

	if (topic === 'New words') {
		question = getNextQuestion(topic)
	} else {
		question = getRandomTest(topic)
	}

	const fullQuestion = `ü•∑\nHow is it translated: <b><u>‚ùó${question.question.toUpperCase()}‚ùó</u></b> <b>${question.text.toLocaleLowerCase()}</b> üëÄ`

	let inlineKeyboard

	const buttonRows = question.options.map(option => {
		return [
			InlineKeyboard.text(
				option.answer.toUpperCase(),
				JSON.stringify({
					type: topic,
					isCorrect: option.isCorrect,
					questionId: option.id
				})
			)
		]
	})

	inlineKeyboard = InlineKeyboard.from(buttonRows)

	await ctx.reply(fullQuestion, {
		reply_markup: inlineKeyboard,
		parse_mode: 'HTML'
	})
})

bot.on('callback_query:data', async ctx => {
	const callbackData = JSON.parse(ctx.callbackQuery.data)

	// –ü–æ–ª—É—á–∞–µ–º –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ —Ç–µ–∫—É—â–µ–º –≤–æ–ø—Ä–æ—Å–µ –∏ —Ç–µ–º–µ
	const currentTopic = callbackData.type.split(' - ')[0]
	const currentQuestionId = callbackData.questionId

	if (callbackData.isCorrect) {
		// –í—ã–±–∏—Ä–∞–µ–º —Å–ª–µ–¥—É—é—â–∏–π –≤–æ–ø—Ä–æ—Å –∏–∑ —Ç–æ–π –∂–µ —Ç–µ–º—ã
		const nextQuestion = getRandomTest(currentTopic)

		const fullQuestion = `ü•∑\nHow is it translated: <b><u>‚ùó${nextQuestion.question.toUpperCase()}‚ùó</u></b> <b>${nextQuestion.text.toLocaleLowerCase()}</b> üëÄ`

		await ctx.reply('‚úÖ Right ‚úÖ')

		let inlineKeyboard

		const buttonRows = nextQuestion.options.map(option => {
			return [
				InlineKeyboard.text(
					option.answer.toUpperCase(),
					JSON.stringify({
						type: `${currentTopic} - option`,
						isCorrect: option.isCorrect,
						questionId: nextQuestion.id
					})
				)
			]
		})

		inlineKeyboard = InlineKeyboard.from(buttonRows)

		await ctx.reply('---üëáNew questionüëá---')
		// –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —Å–ª–µ–¥—É—é—â–∏–π –≤–æ–ø—Ä–æ—Å
		await ctx.reply(fullQuestion, {
			reply_markup: inlineKeyboard,
			parse_mode: 'HTML'
		})

		await ctx.answerCallbackQuery()
		return
	}

	const answer = getCorrectAnswer(currentTopic, currentQuestionId)
	await ctx.reply(
		`‚ùå*Wrong*‚ùå \n \n*Correct answer:‚û°Ô∏è${answer.toUpperCase()}* üëÄ`,
		{ parse_mode: 'Markdown' }
	)
	await ctx.answerCallbackQuery()
})

// –û–±—Ä–∞–±–æ—Ç–∫–∞ –æ—à–∏–±–æ–∫
bot.catch(err => {
	const ctx = err.ctx
	console.error(`Error while handling update ${ctx.update.update_id}:`)
	const e = err.error
	if (e instanceof GrammyError) {
		console.error('Error in request:', e.description)
	} else if (e instanceof HttpError) {
		console.error('Could not contact Telegram:', e)
	} else {
		console.error('Unknown error:', e)
	}
})

// –ó–∞–ø—É—Å–∫ –±–æ—Ç–∞
bot.start()
